{% extends 'base.html' %}

{% load static %}

{% block content %}
<!DOCTYPE html>
<html lang="en" class="notranslate" translate="no">

<head>
  <link rel="stylesheet" type="text/css" href="{% static 'pdfjs\web\main.css' %}">
    <title>Simple PDF Annotator</title>
    <meta charset=utf-8 />
    <meta name="description" content="A Simple PDF Annotator" />
    <meta name="keywords" content="simple, pdf, annotator" />
    </link>
    <meta name="google" content="notranslate" />
    <link href="data:image/x-icon;base64,AAABAAEAEBAAAAAAAABoBQAAFgAAACgAAAAQAAAAIAAAAAEACAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAADAxeYA3+DcAH55ewDg4uIA2+L9AKeorADl5+gAzNDjAJaXlQCsrKYAdlrbAC8x+wD6/v8AMTH7AJiYmACChocA/P7/AISDhwDp6+sAAQD6AP/+/wAAAf0AgH+xAO7w8QCfoJ4Aop2eAJ+i/QDV2/IApZ6hAPL09ADd5ewA9/b6AJOTkwDk5uYAUkbgAKiqqgCEgH8A6OTpAPn/+gCDhIIA+/39AOrn6QD9/f0A1NfVAP//+gDX1tIA//39AOnr7ADn6vIA1tjYANjY2ACLiYgAjI2LAN7c2wDz8PIA9fDyAJCPkQDh4eEA9vf1AMvQ0wBGQfYA9vj4ANDOzQCqrasA6OnnANXT0wD+//sAhoSDAP/9/gCYmZ0AytfxAAED/ACdnpoAiYmJAHt5xQCen50AnqCgANzc3ADv8vAAoqCgAPH18ADz8/MABQG4AN/h4gDy9/YA4uDfAFc/zQDQzNEAlJCVAKepqQDl5eUAMADYAP34+QD6/PwAnIn9AMjR8gD8+v8AmJmVAPz9/wDr6egA/v3/AP/9/wD///wAAAD9AAIA/QA2M/sAYkvWAKirygDZ2NoA2tzdAIuMigAwM70AAAC2AAMAtgD08vEA9fb0APX39wDz+vcAkJKTAF8y5gD8//0A6+npAP7//QDr6uwAAAD+AAAC+wDR4NgAAgD+AHdm3wCIiIgAAAK0AKGdogAEALcA9PLyAAcAtwDCyugAz83NAJOSlADk5OQAlJOXAJeVlADo5ecA+/v7APr//gCurKsAeFzdAP3//gA1MvoA///+AAIB+QB2V/IA6+3tAAMC/ADt7e0A2NriAAIAuAD09fMA4+DiAJGPlQD69/kA+fj8AP76+QD6//8A+///AK6srAD9//8ANwnSAP///wA4IMYA3NvdAO/x8QAoC74Ap6enAOfk5gD6+voA5ujpAC40+QBXVs4A6OvpANXV1QD//v0A7ejpAIiDhQACAfsAAQL+AImKiADt7vIAiYuLAJ+gnADU4OQAxNDQAMrI3ACopqUAqaqoAKurqwAuMv0A09XWAPz+/gD+/v4AAAD5AP/+/gCMh4kAn52dAAABtQB4eHgAdW3vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZZTIWIk0uUkzucmBDyQCzCylxcp7KSmvBoqKOQFtMm6lpXpIErJjJVqtA51VTWy7pS6nwB6rqL61eUCNUzs1IKeUo6w6G2pKX5khfocWqTinp8VZoB+9sW9rClZbppqMxrTIwV0uVBo8RndeAAcvDqfGkiN6tMgEIoAwdFCcuginxacJo2W0dZGWKI5cPR1FlKUqBbR6ZGDNvyZEKJ8XGWaGgsuEm3Fwy3KLQye2EWFiaLjHlbd9R1I3wqKul4grlBOYFX98fGdxUT+hc1ctNqVpDQsLw5OwFSikOj5BTqWUDJSexo94yEIQkMSzqqcUxXpkvBhLTINPdhwxhaWUpwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=" rel="icon" type="image/x-icon" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://kendo.cdn.telerik.com/2017.2.621/js/kendo.all.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

</head>

<body>
    <div id="menubar-wrapper">
        <div class="menuitem" id="title">
            Simple PDF Annotator
            
        </div>
        <div class="menuitem" id="page">
        </div>
        <div class="menuitem" id="gui">
           <!-- Add this button to your existing HTML -->
<button id="share-pdf-button">Share PDF</button>

            <div id="cross" class="symbol"> <span style="color: red;">✗</span></div>
            <div id="tick" class="symbol"> <span style="color: green;">✓</span></div>
            
            <button id="undo-button">Undo</button>
            <button id="erase-pen">Erase Pen</button>
        
            <select class="button" id="select-pen">
                <option value="pen">Pen</option>
                <option value="marker">Marker</option>
                <option value="text">Text</option>
            </select>
            <input id="upload" type="file"  />
            <button class="button" id ="upload-button" style="display: none;">Upload</button>
            <button id="comment-button">Comment</button>
            <button class="button" id="download" style="display: none;">Save</button>
            <button id="save">Save Annotated PDF</button>
        </div>
    </div>
    <div id="canvas-wrapper">

           
        </div>
        
    </div>
    </div>
   
    
</body>
<script>
   

    const pk = window.location.pathname.split('/').filter(Boolean).pop();

    const isMacLike = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
const url = "{{ pdf_file_url }}"; // Remove curly braces

console.log(url);
const pdfjsLib = window["pdfjs-dist/build/pdf"];
pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";
const uploadScale = 2; // pdf resolution
const downloadScale = 0.75; // exported pdf size in scale
let pdfDoc = null;
let renderCount = 0;
let renderingFinished = false;
let fileName = "";
let penType = document.getElementById("select-pen").value;
let isMouseDown = false;
let drawingCanvas = {
    canvas: null,
    rect: null,
    scaleX: 0,
    scaleY: 0
}
let strokes = [];
let strokeIndex = 0;
let pointIndex = 0;

function drawLine(x1, y1, x2, y2, r1, r2) {
    // calculate direction vector of point 1 and 2
    const directionVectorX = x2 - x1;
    const directionVectorY = y2 - y1;
    // calculate angle of perpendicular vector
    const perpendicularVectorAngle = Math.atan2(directionVectorY, directionVectorX) + Math.PI / 2;
    // construct shape
    const path = new Path2D();
    path.arc(x1, y1, r1, perpendicularVectorAngle, perpendicularVectorAngle + Math.PI);
    path.arc(x2, y2, r2, perpendicularVectorAngle + Math.PI, perpendicularVectorAngle);
    path.closePath();
    return path;
}

function drawStrokes() {
    requestAnimationFrame(drawStrokes);
    const numStrokes = strokes.length;
    for (let i = strokeIndex; i < numStrokes; i++) {
        const ctx = strokes[i].ctx;
        const penType = strokes[i].penType;
        const points = strokes[i].points;
        let r = 0;
        if (penType === "pen") {
            // ctx.lineWidth = 1;
             ctx.strokeStyle = "red";
             ctx.fillStyle = "red"; 
            // ctx.lineCap = "round";
            r = 0.5;
        }
        else if (penType === "marker") {
            // ctx.lineWidth = 20;
            // ctx.strokeStyle = "rgba(118, 254, 192, 0.1)";
            // ctx.lineCap = "butt";
            r = 5;
        }
        if (pointIndex == 0) {
            ctx.moveTo(points[0].x, points[0].y);
        }
        const numPoints = points.length;
        for (let j = 0; j < numPoints - 1; j++) {
            const line = drawLine(points[j].x, points[j].y, points[j + 1].x, points[j + 1].y, r, r);
            ctx.fill(line);
        }
        ctx.stroke();
    }
}
drawStrokes();

function renderPage(num, canvas, ctx) {
    pdfDoc.getPage(num).then(function (page) {
        var viewport = page.getViewport({ scale: uploadScale });
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        var renderContext = {
            canvasContext: ctx,
            viewport: viewport
        };
        var renderTask = page.render(renderContext);
        renderTask.promise.then(function () {
            console.log(`Page ${num}/${pdfDoc.numPages} rendering finished`);
            if (++renderCount === pdfDoc.numPages) {
                console.log("All pages rendering finished");
                renderingFinished = true;
            }
        });
    });
}

function renderAllPages(pdfDoc_) {
    pdfDoc = pdfDoc_;
    window.scrollTo(0, 0);
    document.getElementById("page").textContent = `1 / ${pdfDoc.numPages}`;
    const canvasWrapper = document.getElementById("canvas-wrapper");
    canvasWrapper.innerHTML = "";
    renderCount = 0;
    renderingFinished = false;
    for (let i = 0; i < pdfDoc.numPages; i++) {
        const canvas = document.createElement("canvas");
        canvas.classList.add("canvas");
        if (i > 0) {
            canvas.classList.add("page-break");
        }
        canvas.id = `canvas${i}`;
        canvasWrapper.appendChild(canvas);
        const ctx = canvas.getContext("2d");
        renderPage(i + 1, canvas, ctx);
    }
    canvasWrapper.addEventListener("mousedown", function (e) {
        if (isMouseDown || !(e.target instanceof HTMLCanvasElement)) {
            return;
        }
        const canvas = e.target;
        const ctx = canvas.getContext("2d");
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        const point = {
            x: x,
            y: y
        };
        const stroke = {
            ctx: ctx,
            penType: penType,
            points: [point]
        }
        strokes.push(stroke);
        drawingCanvas.canvas = canvas;
        drawingCanvas.rect = rect;
        drawingCanvas.scaleX = scaleX;
        drawingCanvas.scaleY = scaleY;
        isMouseDown = true;
    });

    function finishStroke() {
        if (isMouseDown) {
            strokeIndex++;
            pointIndex = 0;
            drawingCanvas.canvas = null;
            isMouseDown = false;
        }
    }

    canvasWrapper.addEventListener("mousemove", function (e) {
        if (!isMouseDown) {
            return;
        }
        if (e.target !== drawingCanvas.canvas) {
            finishStroke();
            return;
        }
        const x = (e.clientX - drawingCanvas.rect.left) * drawingCanvas.scaleX;
        const y = (e.clientY - drawingCanvas.rect.top) * drawingCanvas.scaleY;
        const point = {
            x: x,
            y: y
        };
        strokes[strokes.length - 1].points.push(point);
    });

    canvasWrapper.addEventListener("mouseup", function (e) {
        finishStroke();
    });

    canvasWrapper.addEventListener("mouseout", function (e) {
        finishStroke();
    });
}

function uploadPDF(file) {
    if (file.name.split('.').pop() !== "pdf") {
        alert("Please upload a PDF file.");
        return;
    }
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const typedarray = new Uint8Array(this.result);
        const loadingTask = pdfjsLib.getDocument(typedarray);
        loadingTask.promise.then(pdfDoc_ => {
            fileName = file.name;
            renderAllPages(pdfDoc_);
        }, function () {
            alert("The uploaded PDF file is corrupted.");
            return;
        });
    };
    fileReader.readAsArrayBuffer(file);
}

document.getElementById("upload").addEventListener("change", function (e) {
    const file = e.target.files[0];
    uploadPDF(file);
});

document.getElementById("upload-button").addEventListener("click", function (e) {
    const upload = document.getElementById("upload");
    upload.click();
});

document.getElementById("download").addEventListener("click", function (e) {
    kendo.drawing.drawDOM("#canvas-wrapper", {
        forcePageBreak: ".page-break",
        paperSize: "auto",
        scale: downloadScale
    }).then(function (group) {
        kendo.drawing.pdf.saveAs(group, fileName);
    })
});

window.addEventListener("scroll", function (e) {
    const canvases = document.getElementsByClassName("canvas");
    for (let i = 0; i < canvases.length; i++) {
        const canvas = canvases[i];
        const canvasRect = canvas.getBoundingClientRect();
        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);
        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);
        const vertInView = (canvasRect.top <= windowHeight) && ((canvasRect.top + canvasRect.height * 0.75) >= 0);
        const horInView = (canvasRect.left <= windowWidth) && ((canvasRect.left + canvasRect.width) >= 0);
        if (vertInView && horInView) {
            document.getElementById("page").textContent = `${Math.min(i + 1, pdfDoc.numPages)} / ${pdfDoc.numPages}`;
            break;
        }
    }
});

document.getElementById("select-pen").addEventListener("change", function (e) {
    console.log(this.value);
    penType = this.value;
});

function highlightDraggedElement(element) {
    if (element.id.substring(0, 6) === "canvas") {
        element.style.opacity = "0.5";
    }
    else if (element === document.body) {
        document.body.style.backgroundColor = "rgb(72, 76, 79)";
    }
}

function revertDraggedElement(element) {
    if (element.id.substring(0, 6) === "canvas") {
        element.style.opacity = "1.0";
    }
    else if (element === document.body) {
        document.body.style.backgroundColor = "rgb(82, 86, 89)";
    }
}

document.body.addEventListener("dragenter", function (e) {
    e.preventDefault();
    highlightDraggedElement(e.target);
});

document.body.addEventListener("dragleave", function (e) {
    e.preventDefault();
    revertDraggedElement(e.target);
});

document.body.addEventListener("dragover", function (e) {
    e.preventDefault();
});

document.body.addEventListener("drop", function (e) {
    e.preventDefault();
    revertDraggedElement(e.target);
    const file = e.dataTransfer.files[0];
    uploadPDF(file);
});

window.addEventListener("keydown", function (e) {
    e = e || window.event;
    const modifierKey = isMacLike ? e.metaKey : e.ctrlKey;
    if (modifierKey) {
        const key = e.which || e.keyCode || 0;
        switch (String.fromCharCode(key).toLowerCase()) {
            case "z":
                if (e.shiftKey) { // redo
                    e.preventDefault();

                }
                else { // undo
                    e.preventDefault();
                }
                break;
        }
    }
});

pdfjsLib.getDocument(url).promise.then(function (pdfDoc_) {
    fileName = url.substring(url.lastIndexOf("/") + 1);
    renderAllPages(pdfDoc_);
});


const csrftoken = getCookie('csrftoken');


document.getElementById("save").addEventListener("click", function (e) {
    kendo.drawing.drawDOM("#canvas-wrapper", {
        forcePageBreak: ".page-break",
        paperSize: "auto",
        scale: downloadScale
    }).then(function (group) {
        // Convert the generated PDF to a data URL
        kendo.drawing.exportPDF(group).done(function(dataUrl) {
            // Create a Blob from the data URL
            const byteCharacters = atob(dataUrl.split(',')[1]);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], { type: 'application/pdf' });

            const formData = new FormData();
            formData.append('pdf_file', blob, fileName);

           
            fetch('/save_pdf/{{ pdf_instance.pk }}/', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                },
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('PDF saved successfully.');
                } else {
                    alert('Error saving PDF: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
        });
    });
});


function getCookie(name) {
    const cookieValue = document.cookie
        .split(';')
        .find(cookie => cookie.trim().startsWith(name + '='));
    
    if (cookieValue) {
        return cookieValue.split('=')[1];
    }

    return null;
}



document.getElementById("erase-pen").addEventListener("click", function (e) {
    clearPenDrawings();
});


// Function to make a symbol resizable
const symbols = document.querySelectorAll('.symbol');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const undoButton = document.getElementById('undo-button');
        
        const placedSymbols = [];
        let activeSymbol = null;
        let eraserMode = false;

        // Function to make a symbol resizable
        function makeSymbolResizable(symbol) {
            let isResizing = false;
            let startX, startY, startWidth, startHeight;

            symbol.addEventListener('mousedown', (e) => {
                if (e.target === symbol) {
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = parseInt(document.defaultView.getComputedStyle(symbol).width, 10);
                    startHeight = parseInt(document.defaultView.getComputedStyle(symbol).height, 10);
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const width = startWidth + e.clientX - startX;
                const height = startHeight + e.clientY - startY;

                // Minimum size to prevent the symbol from becoming too small
                const minWidth = 20;
                const minHeight = 20;

                symbol.style.width = `${Math.max(minWidth, width)}px`;
                symbol.style.height = `${Math.max(minHeight, height)}px`;
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
            });
        }


canvasWrapper.addEventListener('mouseleave', () => {
  if (activeSymbol) {
    canvasWrapper.removeChild(activeSymbol);
    activeSymbol = null;
  }
});

        symbols.forEach(symbol => {
            makeSymbolResizable(symbol);

            symbol.addEventListener('mouseenter', () => {
                if (!eraserMode) {
                    addDeleteButton(symbol);
                }
            });

            symbol.addEventListener('mouseleave', () => {
                if (!eraserMode) {
                    const deleteButton = symbol.querySelector('.delete-button');
                    if (deleteButton) {
                        symbol.removeChild(deleteButton);
                    }
                }
            });

            symbol.addEventListener('mousedown', (e) => {
                if (eraserMode) {
                    canvasWrapper.removeChild(symbol);
                    const index = placedSymbols.indexOf(symbol);
                    if (index !== -1) {
                        placedSymbols.splice(index, 1);
                    }
                } else {
                    activeSymbol = symbol.cloneNode(true);
                    activeSymbol.style.position = 'absolute';
                    canvasWrapper.appendChild(activeSymbol);
                }
            });

            symbol.addEventListener('dragstart', (e) => {
                e.preventDefault();
            });
        });

        canvasWrapper.addEventListener('mousemove', (e) => {
            if (activeSymbol) {
                const x = e.clientX - canvasWrapper.getBoundingClientRect().left;
                const y = e.clientY - canvasWrapper.getBoundingClientRect().top;
                activeSymbol.style.left = x + 'px';
                activeSymbol.style.top = y + 'px';
            }
        });

        canvasWrapper.addEventListener('mouseup', () => {
            if (activeSymbol && !eraserMode) {
                placedSymbols.push(activeSymbol);
                activeSymbol = null;
            }
        });

        undoButton.addEventListener('click', () => {
            if (placedSymbols.length > 0) {
                const lastSymbol = placedSymbols.pop();
                if (lastSymbol.parentElement === canvasWrapper) {
                    canvasWrapper.removeChild(lastSymbol);
                }
            }
        });

       

//Function to generate  a new text element

let isTextDragged = false;
let newTextElement = null;


function createNewTextElement(x, y) {
    newTextElement = document.createElement('div');
    newTextElement.classList.add('text-element');
    newTextElement.style.position = 'absolute';
    newTextElement.style.left = x + 'px';
    newTextElement.style.top = y + 'px';
    newTextElement.setAttribute('contenteditable', 'true');
    newTextElement.addEventListener('keydown', function (e) {
       
        if (e.key === 'Enter') {
            e.preventDefault();
            newTextElement.blur();
            isTextDragged = false;
            newTextElement = null;
        }
    });
    canvasWrapper.appendChild(newTextElement);
    newTextElement.focus();
    isTextDragged = true;
}


canvasWrapper.addEventListener('mousedown', (e) => {
    if (!isTextDragged) {
        const rect = canvasWrapper.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        createNewTextElement(x, y);
    }
});

canvasWrapper.addEventListener('mousemove', (e) => {
    if (isTextDragged && newTextElement) {
        const rect = canvasWrapper.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        newTextElement.style.left = x + 'px';
        newTextElement.style.top = y + 'px';
    }
});

let isCommenting = false;

document.getElementById("comment-button").addEventListener("click", () => {
    isCommenting = true;
    document.body.style.cursor = "crosshair";
});

canvasWrapper.addEventListener('mousedown', (e) => {
    if (isCommenting) {
        const rect = canvasWrapper.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        createCommentBox(x, y);
        isCommenting = false;
        document.body.style.cursor = "default";
    }
});

function createCommentBox(x, y) {
    const commentBox = document.createElement('div');
    commentBox.classList.add('comment-box');
    commentBox.style.position = 'absolute';
    commentBox.style.left = x + 'px';
    commentBox.style.top = y + 'px';
    commentBox.style.backgroundColor = 'white';

    // Created a closed button
    const crossButton = document.createElement('button');
    crossButton.innerHTML = '✖'; 
    crossButton.style.position = 'absolute';
    crossButton.style.top = '5px'; // iniharu le position lai adjust garaucha
    crossButton.style.right = '5px'; 
    crossButton.style.cursor = 'pointer';
    crossButton.addEventListener('click', () => {
       


        //when press the cross button the comment box is removed 
        canvasWrapper.removeChild(commentBox);
    });

    commentBox.appendChild(crossButton);

    // Created a content editable area comment box
    const contentEditable = document.createElement('div');
    contentEditable.setAttribute('contenteditable', 'true');
    contentEditable.style.padding = '10px'; // padding adjust gareko
    contentEditable.style.minHeight = '20px'; // height adjusting
    contentEditable.style.border = '1px solid #ccc'; // border haaleko alli gatilo dekhauna
    commentBox.appendChild(contentEditable);

    canvasWrapper.appendChild(commentBox);
    contentEditable.focus();

    contentEditable.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const br = document.createElement('br');
            contentEditable.appendChild(br);
        }
    });
}


    // Function to copy text to clipboard
    function copyToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
    }

    document.getElementById("share-pdf-button").addEventListener("click", function () {
        // Get the current URL of the page
        const currentUrl = window.location.href;

        // Generate the share URL by adding a unique parameter (e.g., timestamp)
        const shareUrl = `${currentUrl}?share=${Date.now()}`;

        // Create a popup element
        const popup = document.createElement("div");
        popup.classList.add("share-popup");
        popup.innerHTML = `
            <h2>PDF Share URL Generated</h2>
            <p>Share this URL with others:</p>
            <input type="text" id="share-url-input" value="${shareUrl}" readonly>
            <button id="copy-url-button">Copy URL</button>
        `;

        // Append the popup to the body
        document.body.appendChild(popup);

        // Add event listener to copy URL button
        document.getElementById("copy-url-button").addEventListener("click", function () {
            const shareUrlInput = document.getElementById("share-url-input");
            copyToClipboard(shareUrlInput.value);
            alert("URL copied to clipboard!");
        });
    });
    const pdfData = "{{ pdf_data|escapejs }}";

    </script>
     
    <style>
        .text-element {
            border: 1px solid #000;
            background-color: #fff;
            padding: 4px;
            resize: both;
            overflow: auto;
            min-width: 50px;
            min-height: 20px;
            cursor: move;
        }

        .text-element[contenteditable="true"] {
            border: none;
            background-color: transparent;
        }
    </style>
    <style>
        .symbol {
            position: relative;
          display: inline-block; 
          margin-right: 10px; 
        }
      
        .comment-box {
    border: 1px solid #000;
    padding: 4px;
    resize: both;
    overflow: auto;
    min-width: 50px;
    min-height: 20px;
    cursor: move;
}
    
    </style>

<style>
    /* Style for the share popup */
    .share-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
        z-index: 1000;
    }

    .share-popup h2 {
        font-size: 18px;
        margin-bottom: 10px;
    }

    .share-popup input {
        width: 100%;
        padding: 5px;
        margin-bottom: 10px;
    }

    .share-popup button {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 5px 10px;
        cursor: pointer;
    }
</style>

{% endblock %}
